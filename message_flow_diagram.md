# Диаграмма обработки сообщений в боте

## Поток обработки сообщений

```
Пользователь отправляет сообщение
           ↓
    ┌─────────────────┐
    │  admin_router   │ ← Первый в очереди
    │  (кнопки админа)│
    └─────────────────┘
           ↓ (если не обработано)
    ┌─────────────────┐
    │  bind_router    │ ← Обработка start payload
    └─────────────────┘
           ↓ (если не обработано)
    ┌─────────────────┐
    │  start_router   │ ← Команды /start, /help, /cancel
    └─────────────────┘
           ↓ (если не обработано)
    ┌─────────────────┐
    │  write_router   │ ← Написание писем
    │                 │
    │  auto_text_handler │
    │  (обычные сообщения)│
    └─────────────────┘
           ↓ (если не обработано)
    ┌─────────────────┐
    │  relay_router   │ ← Анонимный чат
    │                 │
    │  reply_handler  │
    │  (реплаи)       │
    └─────────────────┘
           ↓ (если не обработано)
    ┌─────────────────┐
    │ channel_router  │ ← Callback кнопки каналов
    └─────────────────┘
```

## Детальное поведение

### 1. Обычные сообщения (НЕ реплаи)
```
Пользователь: "привет, как дела?"
           ↓
    auto_text_handler проверяет:
    - Не админ? ✅
    - Есть активный ящик? ✅
    - Не команда? ✅
    - НЕ реплай? ✅
    - Не кнопка? ✅
    - Не пересланное? ✅
           ↓
    Результат: СОЗДАНИЕ ПИСЬМА
    - Устанавливает состояние WriteStates.INPUT_TEXT
    - Вызывает on_text_input
    - Показывает TTL клавиатуру
```

### 2. Реплаи на сообщения
```
Пользователь: [реплай на сообщение бота] "привет!"
           ↓
    reply_handler проверяет:
    - Приватный чат? ✅
    - Есть реплай? ✅
    - Есть текст? ✅
    - Не команда? ✅
           ↓
    RelayService.handle_reply:
    - Ищет активный релей по ID сообщения
    - Находит собеседника
    - Отправляет сообщение как реплай
           ↓
    Результат: АНОНИМНЫЙ ЧАТ
```

### 3. Команды
```
Пользователь: "/end"
           ↓
    relay_router.cmd_end:
    - Закрывает активные диалоги
    - Уведомляет собеседника
           ↓
    Результат: ЗАВЕРШЕНИЕ ДИАЛОГА
```

## Ключевые особенности

### ✅ Что работает корректно:
1. **Обычные сообщения** → создание письма
2. **Реплаи** → анонимный чат
3. **Команды** → соответствующие действия
4. **Нет конфликтов** между обработчиками

### 🎯 Логика разделения:
- **auto_text_handler**: обрабатывает обычные сообщения, исключает реплаи
- **reply_handler**: обрабатывает только реплаи
- **Порядок роутеров**: write_router ПЕРЕД relay_router

### 💡 Вывод:
**Если пользователь пишет обычное сообщение (не реплай), бот воспринимает это как создание письма, а не как сообщение в анонимном чате.**

Это правильное поведение, так как:
1. Анонимный чат работает только через реплаи
2. Обычные сообщения предназначены для создания писем
3. Нет путаницы между функциями

## Множественные параллельные анонимные чаты

### Сценарий: Автор ведет несколько диалогов одновременно

```
Автор (ID: 100) получает запросы на анонимный чат:

┌─────────────────────────────────────────────────────────────┐
│  Чат 1: Автор(100) <-> ПользовательA(200)                  │
│  - Автор получает сообщение с ID: 1001                     │
│  - ПользовательA получает сообщение с ID: 2001             │
│  - Создается релей в БД с a_message_id=1001, b_message_id=2001 │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  Чат 2: Автор(100) <-> ПользовательB(300)                  │
│  - Автор получает сообщение с ID: 1002                     │
│  - ПользовательB получает сообщение с ID: 3001             │
│  - Создается релей в БД с a_message_id=1002, b_message_id=3001 │
└─────────────────────────────────────────────────────────────┘
```

### Обработка реплаев:

```
Автор отвечает реплаем на сообщение 1001:
           ↓
    get_by_message_id(100, 1001, now):
    - Ищет релей где (a_user_id=100 AND a_message_id=1001)
    - Находит Чат 1
    - Отправляет сообщение ПользователюA(200) как реплай на сообщение 2001
           ↓
    Результат: ✅ Сообщение доставлено в Чат 1

Автор отвечает реплаем на сообщение 1002:
           ↓
    get_by_message_id(100, 1002, now):
    - Ищет релей где (a_user_id=100 AND a_message_id=1002)
    - Находит Чат 2
    - Отправляет сообщение ПользователюB(300) как реплай на сообщение 3001
           ↓
    Результат: ✅ Сообщение доставлено в Чат 2
```

### Ключевые особенности:

#### ✅ Что работает корректно:
1. **Уникальность ID сообщений** - каждый релей имеет уникальные ID сообщений
2. **Точная доставка** - каждый реплай идет к правильному получателю
3. **Независимость чатов** - чаты не влияют друг на друга
4. **Безопасность** - сообщения не перепутываются

#### 🔍 Логика поиска:
```sql
SELECT * FROM relays 
WHERE ((a_user_id=? AND a_message_id=?) OR (b_user_id=? AND b_message_id=?)) 
AND expires_at > ?
ORDER BY id DESC LIMIT 1
```

#### 💡 Вывод:
**Бот полностью корректно работает с множественными параллельными анонимными чатами!**

- ✅ Автор может вести несколько диалогов одновременно
- ✅ Каждый реплай доставляется правильному собеседнику
- ✅ Сообщения не перепутываются между чатами
- ✅ Система масштабируется на любое количество параллельных диалогов
