# Кэширование ролей пользователей

## Обзор

Реализован высокопроизводительный кэш для ролей пользователей, который значительно снижает нагрузку на базу данных и ускоряет проверку прав доступа.

## Проблема

До внедрения кэша проверка ролей выполнялась для каждого сообщения:
- `RolesMiddleware` - для каждого сообщения
- `is_admin_db()` - в различных обработчиках  
- `PermissionMiddleware` - для проверки доступа

При активном использовании бота это приводило к множественным запросам к БД.

## Решение

### Архитектура кэша

```python
class RoleCache:
    def __init__(self, ttl_seconds: int = 300):  # 5 минут TTL
        self._cache: Dict[int, tuple[str, float]] = {}  # user_id -> (role, timestamp)
        self._ttl = ttl_seconds
        self._lock = asyncio.Lock()
```

### Ключевые особенности

1. **TTL (Time To Live)** - автоматическое истечение кэша через 5 минут
2. **Thread-safe** - использование asyncio.Lock для безопасности
3. **Автоматическая инвалидация** - обновление при изменении ролей
4. **Статистика** - мониторинг производительности
5. **Фоновая очистка** - автоматическое удаление устаревших записей

### Интеграция

#### 1. RolesMiddleware
```python
async def __call__(self, handler, event, data):
    user = data.get("event_from_user")
    if user:
        role = await self.role_cache.get_role(user.id, self.users.get_role)
    data["role"] = role
    return await handler(event, data)
```

#### 2. UsersRepo
```python
async def upsert(self, user_id: int, role: Optional[str] = None):
    # ... обновление БД ...
    
    # Обновляем кэш ролей
    await role_cache.update_role(user_id, role)
```

#### 3. Инициализация в main.py
```python
# Инициализируем кэш ролей
role_cache = init_role_cache(ttl_seconds=300)  # 5 минут TTL
await role_cache.start_cleanup_task(interval_seconds=60)  # Очистка каждую минуту
```

## Производительность

### Метрики

- **TTL**: 5 минут (настраивается)
- **Очистка**: каждую минуту
- **Thread-safe**: да
- **Автообновление**: да

### Статистика

Команда `/cache_stats` показывает:
- Размер кэша
- Количество попаданий/промахов
- Процент попаданий
- Количество обновлений/инвалидаций

### Ожидаемые результаты

- **Снижение нагрузки на БД**: до 90% для активных пользователей
- **Ускорение проверки ролей**: с ~1ms до ~0.01ms
- **Масштабируемость**: поддержка тысяч пользователей

## API

### Основные методы

```python
# Получить роль с кэшированием
role = await cache.get_role(user_id, fetch_func)

# Обновить роль в кэше
await cache.update_role(user_id, new_role)

# Инвалидировать пользователя
await cache.invalidate_user(user_id)

# Очистить весь кэш
await cache.invalidate_all()

# Получить статистику
stats = cache.get_stats()
```

### Команды администратора

- `/cache_stats` - статистика кэша ролей
- `/state_info` - информация о FSM состояниях

## Конфигурация

### Настройки TTL

```python
# В main.py
role_cache = init_role_cache(ttl_seconds=300)  # 5 минут
```

### Рекомендуемые значения

- **TTL**: 300 секунд (5 минут) - баланс между производительностью и актуальностью
- **Очистка**: 60 секунд - регулярная очистка устаревших записей
- **Для высоконагруженных систем**: TTL 600 секунд (10 минут)

## Мониторинг

### Ключевые метрики

1. **Процент попаданий** - должен быть > 80%
2. **Размер кэша** - мониторинг использования памяти
3. **Количество обновлений** - частота изменений ролей

### Алерты

- Процент попаданий < 60% - проверить настройки TTL
- Размер кэша > 10000 записей - рассмотреть увеличение TTL
- Частые обновления - проверить логику изменения ролей

## Безопасность

### Защита от race conditions

- Использование `asyncio.Lock` для всех операций
- Атомарные операции обновления
- Проверка валидности данных

### Инвалидация

- Автоматическая при изменении ролей
- Ручная через API
- По истечении TTL

## Совместимость

- ✅ Обратная совместимость с существующим кодом
- ✅ Работает со всеми middleware
- ✅ Поддерживает все типы ролей
- ✅ Интегрируется с существующей системой прав

## Заключение

Кэш ролей обеспечивает:

1. **Высокую производительность** - снижение нагрузки на БД
2. **Масштабируемость** - поддержка большого количества пользователей  
3. **Надежность** - автоматическая инвалидация и очистка
4. **Мониторинг** - детальная статистика работы
5. **Простота** - прозрачная интеграция с существующим кодом

Рекомендуется для всех Telegram-ботов с активной пользовательской базой.
